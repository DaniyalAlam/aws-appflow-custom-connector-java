## Query Filter Parser

## What are query filter expressions?
Query filter expressions are used to express data filtering options at the source in AppFlow. The domain specific language 
(DSL) that defines the filter expressions grammar is AppFlow specific. For example: `price > 100 and accountName contains "Alexa"`. 
The query expression DSL is a normalized DSL and not specific to DSLs used by specific underlying applications. The connector's 
job is to provide the necessary translation from AppFlow DSL to application specific DSL or other syntax the underlying 
application requires.

## Why are filter expressions needed in the custom connector SDK?
AppFlow works in incremental query model. It takes the user input for filtering in a flow and translates it to a normalized 
DSL and passes it on to connectors. Connectors then take that normalized expression and translate it to application specific 
format.

## What is the end-to-end flow that AppFlow uses for querying data from the source connectors?
When an AppFlow user creates a flow definition with a custom connector as source and adds some filters in it, AppFlow converts 
these filters into filter expression and invokes the `query_data` function in the custom connector Lambda with `QueryDataRequest` 
as an input parameter. The request object contains metadata for the target source object and the translated filter-expression 
string. 

For example, an AppFlow user wants to query the subset of data with the `Account` entity from Salesforce. The `QueryDataRequest` 
object contains metadata associated with the `Account` entity and filter expression representing the filters defined in 
the flow definition.

The connector implementation for the read_data Lambda function is expected to parse this filter expression into the connector-specific expression. For example, the filter expression `price > 100 AND accountName CONTAINS "Alexa"` should be 
translated to a Salesforce-specific filter expression as: ` price > 100 AND accountName LIKE '%Alexa%' `.

The translated filter expression can then be passed as a query string along with the Salesforce query REST API.

## What are the various operators that are supported in the query filter DSL?

Currently the filter expression DSL supports a limited set of operators:

* AND
    - attribute1 > value1 *AND* attribute2 > value2
* OR
    - attribute1 > value1 *OR* attribute2 > value2
* BETWEEN   <value1> and <value2>
    - attribute1 *BETWEEN* value1 *AND* value2
* \> (greater than)
    - attribute1 *>* value1
* \>= (greater than equal to)
    - attribute1 *>=* value1
* < (less than)
    - attribute1 *<* value1
* <= (less than equal to)
    - attribute1 *<=* value1
* = (equal to)
    - attribute1 *=* value1
* != (not equal to)
    - attribute1 *!=* value1
* NULL
    - attribute1 = *NULL*
* IN
    - attribute1 *IN* *(* value1, value2, value3 *)*
* CONTAINS
    - attribute *CONTAINS* 'Alexa'


## Can the filter expressions be nested?
Yes, the filter expressions can be nested. The DSL supports multiple level of nesting. For instance, 
`price > 100 and ( accountName contains 'Alexa' OR accountName contains 'Device')`. The connector handles multiple levels of nesting. If the nesting depth is more than what the underlying application can 
support, it throws an exception.

## What are the various datatypes that are supported for the fields in filter expression?
The expressions in the DSL consist of 1) left operand (the field-name of an entity) 2) a logical operator 
(e.g. AND, OR, BETWEEN) and 3) the right operand (the field-value). Following are some of the supported data-types 
for the field-value:

1. Boolean values will be represented as String. Valid values: True  or  TRUE or true or FALSE or false or False.
2. DateTime value will be represented in ISO date-time format (YYYY-MM-DDThh:mm:ss.sTZD)
3. String value will wrapped around either single or double quote ('value' or "value")
4. Empty string will be represented by ('' or "")


## How can I parse the filter expressions?
The SDK comes bundled with a parser to help parse the filter-parser expressions. The parser is available in the 
custom_connector_queryfilter module. The parser is built using antlr4 based grammar and bundles the files generated by 
the antlr4 compiler.

## How can I learn more about antlr?
https://www.antlr.org/

## Do I need to really be an expert in antlr in order to use the parser?
No. If you follow the example, parsing the query parser with CustomConnectorParseTreeBuilder is only few lines of code. 
In addition to that the connector developer needs to provide an implementation of CustomConnectorQueryFilterParserBaseVisitor for which you can start by looking at the example SalesForceQueryFilterExpressionVisitor and start from there.

## Why does the SDK come bundled with the query filter parser?
One of the input parameters for query_data function is 'filter-expression' which uses AppFlow DSL. In order to simplify 
the work needed to parse the filter expression the parser has been included.

## How do I validate the passed in filter expression?
Connector implementation can utilize the ‘CustomConnectorParseTreeBuilder.parseTree(String filterExpression)’ method 
inside custom-connector-queryfilter package. Consider this example code:

```java
ParseTree parseTree = CustomConnectorParseTreeBuilder.parse(filterExpression);
SalesForceQueryFilterExpressionVisitor salesForceQueryFilterExpressionVisitor
     = new SalesForceQueryFilterExpressionVisitor(entityDefinition);
// visit the parse tree to convert the filter expression into salesforce filter query
salesForceQueryFilterExpressionVisitor.visit(parseTree);
// return the salesforce filter expression build by visiting the filter expression
return salesForceQueryFilterExpressionVisitor.getResult();
```

If the filterExpression is badly formed the parse() function will throw 'InvalidFilterExpressionException' exception. 
This method return the ParseTree which can be handed over to a visitor implementation (see: CustomConnectorQueryFilterParserVisitor) 
to form connector specific queryString. Please refer to the custom-connector-example package to learn more about how to 
use this parser.

## How do I implement the visitor implementation for navigating through the ParseTree?

The `filterExpression` is parsed by `CustomConnectorQueryFilterParser` and results into ParseTree. Connector 
implementation should extend the `CustomConnectorQueryFilterParserBaseVisitor` class and override required method to 
visit parse tree. Please checkout `com.amazonaws.appflow.custom.connector.example.query.SalesForceQueryFilterExpressionVisitor` 
in the `custom-connector-example` module to see the details.

## How do I build the connector specific queryString?
In the bundled example, we have created `SalesForceQueryFilterExpressionVisitor class` which extends 
`CustomConnectorQueryFilterParser` visitor class. We will use this class to generate the connector specific query string. 
This example generates Salesforce connector specific queryString. This example uses an instance variable `queryBuilder` 
(java.lang.StringBuilder) to help construct the final query expression while navigating the parse tree in the visitor. 
AppFlow has defined following set of expressions in the AppFlow grammar.

```
| NOT expression                                  # notExpression
| left=expression op=andBinary right=expression   # aNDBinaryExpression
| left=expression op=orBinary right=expression    # oRBinaryExpression
| left=identifier op=gtComparator right=value     # greaterThanComparatorExpression
| left=identifier op=geComparator right=value     # greaterThanEqualToComparatorExpression
| left=identifier op=ltComparator right=value     # lesserThanComparatorExpression
| left=identifier op=leComparator right=value     # lesserThanEqualToComparatorExpression
| left=identifier op=eqComparator right=value     # equalToComparatorExpression
| left=identifier op=eqComparator right=bool      # boolEqualToComparatorExpression
| left=identifier op=neComparator right=value     # notEqualToComparatorExpression
| left=identifier op=neComparator right=bool      # boolNotEqualToComparatorExpression
| left=identifier op=likeComparator right=value   # likeComparatorExpression
| (left=identifier op=betweenComparator (l1=value op1=andBinary right=value)) #betweenExpression
| identifier #identifierExpression// Following is a leaf node in the parse tree// This allows validation and transformations of values.
| value #valueExpression
| identifier op=in LPAREN value (COMMA value)* RPAREN  # inExpression  // Supports SQL like 'IN' operator
```
`CustomConnectorQueryFilterParserBaseVisitor` provides a specific method to visit each expression. Connector 
implementation needs to override the specific method and form the connector specific queryString. Antlr runtime library 
traverses the parseTree and invokes the methods in the visitor. For example for parsing the BETWEEN expression in 
`LastModifiedDate between 2021-08-21T05:06:07Z and 2021-08-22T05:06:07Z`, the visitor implementation needs to override 
`visitBetweenExpression` from the base class. 

Here is the example implementation from `SalesForceQueryFilterExpressionVisitor:`

```java
@Override
public StringBuilder visitBetweenExpression(final CustomConnectorQueryFilterParser.BetweenExpressionContext ctx) {
  if (ctx.getChildCount() == 5) {
    String identifier = ctx.getChild(0).getText();
    String lowerBound = ctx.getChild(2).getText();
    String upperBound = ctx.getChild(4).getText();
    // Identify the datatype of identifier and format it accordingly while building query
    String dataType = getFieldDatatype(ctx.getChild(0).getText()).dataType().name();
    return queryBuilder
      .append(String.format(CONDITION_FORMAT, identifier, COMPARISON_GREATER,
          FORMATTER.formatValue(lowerBound, dataType, COMPARISON_GREATER)))
      .append(LOGICAL_AND)
      .append(String.format(CONDITION_FORMAT, identifier, COMPARISON_LESSER,
          FORMATTER.formatValue(upperBound, dataType, COMPARISON_LESSER)));
  }
  return visitChildren(ctx);
}
```
This example first checks that `betweenExpressionContext` should contain following 5 child nodes

- `LastModifiedDate` identifier (a field name in Salesforce)
- `BETWEEN` operator
- `2021-08-21T05:06:07Z` (field value)
- `AND` operator
- `2021-08-22T05:06:07Z` (field value)

The connector implementation needs to convert this expression into a connector-specific queryString like 
`ModifiedDate > 2021-08-21T05:06:07Z and ModifiedDate < 2021-08-22T05:06:07Z` and store it in queryBuilder instance variable. 
Please refer to custom-connector-example in the SDK to know how other method can be overridden. Note that for the BETWEEN 
operator, the first operand value should always be smaller than the second operand value.

## How do I validate the field identifiers present in query filter expressions?
AppFlow passes the entity metadata information for the queries entity along with the `ConnectorContext` in the 
`QueryDataRequest`. The connector implementation can utilize the entity metadata in their visitor implementation to 
validate the attribute names. This metadata can be used for validation of attribute names at source.

```java
// constructor
public SalesForceQueryFilterExpressionVisitor(final EntityDefinition entityDefinition) {
  Objects.requireNonNull(entityDefinition,
    "entityDefinition can't be null as it is required for building filter query");
  this.entityDefinition = entityDefinition;
}
// How to validate the identifier aka attributeName at the source
private FieldDefinition getFieldDatatype(final String fieldName) {
  return entityDefinition.fields().stream()
      .filter(field -> StringUtils.equals(field.fieldName(), fieldName))
      .findFirst().orElseThrow(() -> new IllegalStateException(
          "Filter attribute not found in entity definition"));
}
```

## How do I validate supported operators on specific attributes in the filter expression?
The connector implementation can use the entity metadata information to validate the supported operators for each field. Each fieldDefinition in the metadata has supported `filterOperator()`. The connector implementation should not allow attributes having boolean datatype in the between expression. For example, `purchaseStatus between true and false` is a valid filter expression as per AppFlow grammar, however it is not valid for the Salesforce connector implementation. the connector implementation should throw exception in such scenarios. Boolean attribute should only support `equal or not equal` operators.

## How do I validate the value/format of each of the attributes in the filter expression?
The connector implementation can use the metadata information to validate if the identifier values in the filter expression follow 
the correct datatype and format. For example, `LastModifiedDate` is a date-time data type field in the Salesforce 
metadata. It should also follow the ISO date-time format in the filter expression. If date-time is passed as a long value 
or other format in the filter expression, the connector implementation should throw an exception. Connector implementation should also format or convert the value as per source connector requirement. For example, if source connector requires the date-time in epoch second than the user should convert ISO date-time into epoch second while building the connector specific query string.

## Where do I get hold of entity metadata to validate attributes and its operator?
This metadata (entityDefinition) is passed in the ConnectorContext object inside the QueryDataRequest object while invoking the lambda to query the data.

## How do I return the connector-specific query?
The connector implementations can add an instance variable to store the connector specific query string. 
In Java for example, the connector implementation can use StringBuilder to build the query and keep appending the expression as Antlr traverses the ParseTree. 
You can define the custom method in the class to return the final result. In the `custom-connector-example`, we have defined it in the following way:

```java
// Returns the final query expression built for Salesforce
public String getResult() {
   return queryBuilder.toString();
}

// Use of the generated string (result)
private static String translateFilterExpression(final String filterExpression, final EntityDefinition entityDefinition) {
   if (StringUtils.isNotBlank(filterExpression)) {
        ParseTree parseTree = CustomConnectorParseTreeBuilder.parse(filterExpression);
        SalesForceQueryFilterExpressionVisitor salesForceQueryFilterExpressionVisitor 
            = new SalesForceQueryFilterExpressionVisitor(entityDefinition);
        // visit the parse tree to convert the filter expression into salesforce filter query
        salesForceQueryFilterExpressionVisitor.visit(parseTree);
        // return the salesforce filter expression build by visiting the filter expression
        return salesForceQueryFilterExpressionVisitor.getResult();
    }
    // no filter expression is defined
    return StringUtils.EMPTY;
}

```

## In case of error, what is a valid error code to return?
The connector implementation should return the ErrorDetails with `ErrorCode.InvalidArgument` and details capturing the actual error. Errors could be related to syntax or datatype and format of value or invalid identifier (aka attributeName).

## Can I generate my own filter library out of Antlr grammar in other languages?
Yes, if that language is supported by antlr4. We have packaged our grammar along with the SDK. You can generate your own 
parser library by compiling the grammar files with antlr4.

